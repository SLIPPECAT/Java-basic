<h1>객체지향 Part.1 </h1>
<h2> 클래스와 객체</h2>
클래스: 객체를 정의해 놓은 것, 용도: 객체를 생성하는 데 사용<br>
객체: 실제로 존재하는 것, 용도: 객체가 가지고 있는 속성과 기능에 따라 다름 (일반적 용어)<br>
인스턴스: 클래스로부터 생성된 객체 (구체적 용어)<br>
인스턴스화: 클래스 => 인스턴스(객체)<br>
<h2>객체의 생성과 배열</h2>
<h3>객체의 생성</h3>
클래스명의 변수명: 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명
객체 생성 방법
Tv t; // Tv클래스 타입의 변수 t 선언
t = new Tv(); Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
<h3>객체의 사용</h3>


<h3>객체 배열</h3>
Tv[] tvArr = new Tv[3]
Tv[] tvArr;
tvArr = new TV[3]

<h2>클래스의 정의</h2>
클래스 == 데이터+함수
<h3>클래스의 탄생 과정</h3>
1. 변수: 하나의 데이터 저장 공간
2. 배열: 같은 타입의 여러 데이터를 하나로 저장할 수 있는 공간
3. 구조체: 서로 연관된 여러 데이터(종류 관계x)를 하나로 저장할 수 있는 공간
4. 클래스: 데이터와 함수의 결합(구조체+함수)

<h3>클래스 == 사용자 정의 타입</h3>
원하는 타입을 직접 만들 수 있다.
기본형8개가 아닌 새로운 타입인 시간 클래스를 작성
String 타입은 참조형, heap영역에 생성?
사용자 3명의 시간을 기록하려고 한다.
<h2>변수의 종류</h2>
<h3>선언 위치에 따른 변수의 종류</h3>
선언위치가 클래스 영역: 클래스 변수(클래스가 올라갈 때 생성), 인스턴스 변수(인스턴스 생성될 때 생성)
선언위치가 메서드 영역: 지역변수(변수 선언문 수행시 생성)
<h2>메서드</h2>

   반환타입, 메서드이름(타입 변수명, ...) //(선언부)
   {
     // 메서드가 호출되면 수행할 코드 (구현부)
   }
<h3>메서드의 장점과 작성</h3>
장점:중복 코드 제거, 관리 용이, 재사용 가능
작성: 하나의 메서드는 한 가지 기능만 수행하도록 작성, 반복적으로 수행되는 여러 문장을 메서드로 작성
<h3>함수</h3>
값을 입력 받아서 처리하고, 결과를 반환

  int add(int x, int y){
  => int(반환타입) add(메서드 이름) int x, int y(매개변수(입력))
  int result = x+y;
  => 처리 
  return result; 
  => 결과를 반환
  }

  void(반환타입): 메서드 수행 아무것도 반환하지 않을 때 사용
<h3>매서드 호출</h3>
메서드이름(값1, 값2...);
<h3>return</h3>
실행 중인 메서드를 종료하고 호출한 곳으로 돌아간다.
반환타입이 void가 아닌 경우 반드시 return문이 필요하다.
void는 컴파일러가 자동으로 메서드 마지막에 return;을 추가해준다.
<h3>문장들의 묶음</h3>
코드의 중복을 하나의 묶음으로 만들어 코드의 가독성 및 효율을 높여준더ㅏ.
<h3>호출스택(call stack)</h3>
메서드 수행에 필요한 메모리가 저장되는 공간
메서드가 호출되면 호출 스택에 메모리가 할당, 종료되면 해제된다.
<h2>기본형 매개변수와 참조형 매개변수</h2>
기본형 매개변수: 변수의 값을 읽기만 할 수 있습니다.
참조형 매개변수: 변수의 값을 읽고 변경할 수 있습니다.
<h3>static 메서드와 인스턴스 메서드</h3>
static 메서드(클래스 메서드)
객체 생성 없이 '클래스이름.메서드이름()'으로 호출:ex)
Math.random()
인스턴스 멤버(인스턴스 변수, 인스턴스 메서드)와 관련없는 작업을 하는 메서드
메서드 내에서 인스턴스 변수 사용 불가
인스턴스 메서드
인스턴스를 생성한 후, '참조변수.메서드이름()'으로 호출
인스턴스 멤버(인스턴스 변수, 인스턴스 메서드)와 관련된 작업을 하는 메서드
메서드 내에서 인스턴스 변수 사용 가능
<h2>오버로딩</h2>
한 클래스 안에 같은 이름의 메서드를 여러 개 정의하는 것
오버로딩의 성립 조건
1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입, 위치가 달라야 한다. (위치가 어떤 의미지?..)
3. 반환타입에는 영향을 받지 않는다.

목적: 매개변수 즉, 입력하는 값이 다르지만 같은 기능을 수행하는 경우가 많을 때 효율을 높기이 위해 오버로딩을 사용.

<h2>생성자</h2>
인스턴스가 생성될 때마다 호출되는 '인스턴스 초기화 메서드'이다.
인스턴스 생성시 수행할 작업에 사용된다.
초기값이 필요한 인스턴스 변수의 값을 초기화해준다.
<h3>생성조건</h3>
1. 이름이 클래스 이름과 같아야 한다.
2. return 값이 없다.
3. void는 붙지 않는다.
4. 오버로딩이 가능하다.

<h3>기본 생성자</h3>
매개변수가 없는 생성자를 의미한다.
생성자가 하나도 선언되지 않았을 때 컴파일러가 자동으로 추가해준다.

<h2>this와 this()</h2>
<h3>this</h3>
1. 인스턴스 자신을 가리키는 참조변수이다.
2. 인스턴스 메서드(생성자 포함)에서 사용가능하다.
3. 지역 변수와 인스턴스 변수를 구분할 때 사용
<h3>this()</h3>
1. 생성자에서 다른 생성자를 호출할 때 사용한다.
2. this()를 사용하지 않고 클래스명(); 이렇게 생성자를 호출하려고 하면 Error가 발생한다.
3. 다른 생성자 호출시 첫 줄에서만 사용가능하다.

<h2>변수의 초기화</h2>
수동/자동 초기화
1. 지역 변수: 수동 초기화
-지역 변수가 동작하는 스택 메모리는 재사용이 빈번하기 때문에 매번 초기화 해주면 성능이 떨어진다.
-그래서 그냥 해당 메모리에 있는 값으로 덮어 씌운다.
-근데 해당 주소에 어떠한 값이 있는지 모르기 때문에 Java는 개발자에게 수동으로 초기화하라고 요구합니다.
-C언어에서는 이를 garbage value라 부릅니다. (C언어와 Java의 차이를 비교하면 이해가 쉽습니다.)
2. 멤버 변수의 초기화
-클래스 변수: 클래스가 처음 로딩될 때 단 한번만 00초기화 된다.
-인스턴스 변수: 인스턴스가 생성될 때마다 초기화 된다.
<h3>초기화 방법</h3>
1. 명시적 초기화(=)
기본형 변수, 참조형 변수의 초기화 (참조형은 객체 주소 또는 null로 초기화)
2. 초기화 블럭
3. 생성자 초기화

<h3>this()</h3>
<h2>과제</h2>



<h1></h1>

<h1></h1>

<h1></h1>

<h1></h1>

<h1></h1>
