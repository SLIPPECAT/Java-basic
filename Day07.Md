<h1>객체지향 Part.2</h1>
<h2>상속</h2>
기존의 클래스로 새로운 클래스를 작성하는 것. 두 클래스를 부모와 자식으로 맺어주는 것
extends 키워드를 사용하여 관계를 맺어준다.
<h3>상속의 조건</h3>
1. 자손은 조상의 모든 멤버를 상속 받는다.
- 생성자와 초기화 블럭은 제외된다.
2. 자손의 멤버 개수는 조상보다 적을 수 없다.
- 항상 같거나 많다.
3. 자손의 변경은 조상에게 영향을 미치지 않는다.

<h3>포함 관계</h3>
클래스의 멤버로 참조변수를 선언하는 것
작은 단위의 클래스를 만들고, 이들을 조합해서 클래스를 만든다.

<h3>관계 결정</h3>
상속관계: ~은 ~이다. (is-a)
포함관계: ~은 ~을 가지고 있다. (has-a)
<h3>단일 상속</h3>
Java는 단일 상속만을 허용한다.
비중이 높은 클래스 하나만 상속관계로 하고 나머지는 포함관계를 사용하는 방법으로 풀어낼 수 있다.
다중 상속을 허용할 경우 문제가 발생할 수 있다. (Diamond Problem)
<h3>Object 클래스</h3>
모든 클래스의 조상이다.
- 부모가 없는 클래스는 컴파일러에 의해 자동으로 Object클래스를 상속받게 된다.
- 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받게 된다.

<h2>오버라이딩</h2>
상속받은 조상의 메서드를 자신에게 맞게 변경하는 것
1. 선언부는 변경 불가능
2. 메서드 내부의 내용만 변경할 수 있다.
<h3>오버라이딩의 조건</h3>
1. 선언부가 조상 클래스의 메서드와 일치해야 한다.
2. 접근 제어자를 조상 클래스의 메서드 보다 좁은 범위로 변경할 수 없다.
3. 예외는 조상 클래스의 메서드 보다 많이 선언할 수 없다.
<h3>오버로딩과 오버라이딩 비교하기</h3>
오버로딩: 기존에 없는 새로운 메서드를 정의하는 것(생성자 모양의 다른 메서드)
오버라이딩: 상속받은 메서드의 내용을 변경하는 것

<h2>super와 super()</h2>
<h3>super</h3>
객체 자신을 가리키는 참조변수
인스턴스 메서드(생성자)내에서만 존재한다.
조상의 멤버를 자신의 멤버와 구별할 때 사용한다.
<h3>super()</h3>
조상의 생성자를 호출할 때 사용
조상의 멤버는 조상의 생성자를 호출해서 초기화한다.
생성자의 첫 줄에 반드시 생성자를 호출해야 한다.
- 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 자동으로 삽입한다.

<h2>package와 import</h2>
<h3>package</h3>
서로 관련된 클래스의 묶음이다.
패키지를 하나의 폴더라고 생각하면 된다.
클래스의 실제 이름은 패키지를 포함한다. (java.lang.String)
<h3>package 선언</h3>
패키지는 소스파일의 첫 번째 문장으로 단 한번만 선언한다.
같은 소스 파일의 클래스들은 모두 같은 패키지에 속한다.
패키지 선언이 없으면 default 패키지에 속하게 된다.
<h3>클래스 패스(classpath)</h3>
클래스 파일(.class)의 위ㅏ치를 알려주는 경로
classpath(환경변수)로 관리하며 경로간의 구분자는 ';'를 사용한다.
classpath에 패키지의 루트를 등록해줘야 한다.
<h3>import</h3>
클래스를 사용할 때 패키지 이름을 생략할 수 있게 해준다.
컴파일러에게 클래스가 속한 패키지를 알려준다.
java.lang 패키지는 중요한 클래스들이 모여있는 패키지이기 때문에 import를 생략할 수 이쎅 되어있다.(String,Object, System)
선언 방법: import 패키지명.클래스명;
import는 패키지와 클래스 선언 사이에 존재한다.
<h3>static import</h3>
static 멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.
- import static java.lang.System.out;
- 위처럼 선언 해주면 out.println("출력!"); 이렇게 사용할 수 있다.

<h2>접근제어자</h2>
<h3>제어자</h3>
클래스와 클래스의 멤버(변수, 메서드)에 부가적인 의미를 부여한다.
- 접근 제어자: public, protected, (default), private
- 그 외: static, final, abstract ...
하나의 대상에 여러 제어자를 같이 사용 가능하다.(접근 제어자는 하나만))
- 순서는 상관 없지만 주로 접근 제어자를 제일 왼쪽에 선언한다.
- public static void main(String[] args){}
<h3>static</h3>
멤버변수, 메서드, 초기화 블럭에 static이 사용될 수 있다.
<h3>final</h3>
클래스, 메서드, 멤버변수, 지역변수에 final이 사용될 수 있다.
대표적인 final 클래스로 String과 Math가 있다.
생성자를 이용하여 final 멤버변수를 초기화 할 수 있다.
- final이 붙은 변수는 상수이기 때문에 보통은 선언과 동시에 초기화를 진행해야 하지만 인스턴스 변수의 경수 생성자에 의해 초기화할 수 있다.
❗️final을 쓴 적이 많이 없어서 정확히는 모르겠다. 예시 확인하자!
<h3>abstract</h3>
클래스, 메서드에 abstract이 사용될 수 있다.
<h3>접근제어자</h3>
private: 같은 클래스 내에서만 접근이 가능하다.
default: 같은 패키지 내에서만 접근이 가능하다.(생략 가능)
protected: 같은 패키지 내에서, 그리도 다른 패키지의 자손 클래스에서 접근이 가능하다.
public: 접근 제한이 전혀 없다.

주의사항
1. 메서드에 static과 abstract를 함께 사용할 수 없다. (static은 몸통이 있는 메서드에만 사용할 수 있다.)
2. 클래스에 abstract와 final을 동시에 사용할 수 없다. (클래스에 사용되는 final은 클래스를 완성할 수 없다는 의미, abstract는 상속을 통해 완성되어야 한다는 의미이므로 서로 모순된다.)
3. abstract메서드의 접근 제어자가 private일 수 없다. (asbstact 메서드는 자손 클래스에 구현하기 위해 접근해야 하기 때문이다.)
4. 메서드에 private와 final을 같이 사용할 필요는 없다. (접근제어자가 private인 메서드는 오버라이딩 될 수 없기 때문이다. 둘 중하나만 사용해도 의미가 충분하다.)

<h2>캡슐화</h2>
<h3>접근 제어자를 사용하는 이유?</h3>
외부로부터 데이터를 보호하기 위해 사용한다.
내부적으로만 사용되는 것을 외부로 노출시키지 않고 감추기 위해서 사용된다.
이렇게 데이터를 보호하는 것을 캡슐화라고 부른다.

for 


<h2>캡슐화</h2>





<h2>캡슐화</h
<h3></h3>
<h3></h3>
<h2>다양성</h2>
<h3></h3>
<h3></h3>

<h2>참조변수의 형변환</h2>

<h3></h3>
<h3></h3>
<h2>매개변수 다형성</h2>
<h3></h3>
<h3></h3>
<h2>추상 클래스</h2>
<h3></h3>
<h3></h3>
<h2>인터페이스</h2>
<h3></h3>
<h3></h3>

<h2>인터페이스의 다형성</h2>
<h3></h3>
<h3></h3>
<h2>인터페이스의 장점</h2>
<h3></h3>
<h3></h3>
  
  
<h3></h3>
<h1><h1/>
<h1><h1/>
<h1><h1/>
<h1><h1/>
