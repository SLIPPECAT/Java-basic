<h1>객체지향 Part.2</h1>
<h2>상속</h2>
기존의 클래스로 새로운 클래스를 작성하는 것. 두 클래스를 부모와 자식으로 맺어주는 것
extends 키워드를 사용하여 관계를 맺어준다.
<h3>상속의 조건</h3>
1. 자손은 조상의 모든 멤버를 상속 받는다.
- 생성자와 초기화 블럭은 제외된다.
2. 자손의 멤버 개수는 조상보다 적을 수 없다.
- 항상 같거나 많다.
3. 자손의 변경은 조상에게 영향을 미치지 않는다.

<h3>포함 관계</h3>
클래스의 멤버로 참조변수를 선언하는 것
작은 단위의 클래스를 만들고, 이들을 조합해서 클래스를 만든다.

<h3>관계 결정</h3>
상속관계: ~은 ~이다. (is-a)
포함관계: ~은 ~을 가지고 있다. (has-a)
<h3>단일 상속</h3>
Java는 단일 상속만을 허용한다.
비중이 높은 클래스 하나만 상속관계로 하고 나머지는 포함관계를 사용하는 방법으로 풀어낼 수 있다.
다중 상속을 허용할 경우 문제가 발생할 수 있다. (Diamond Problem)
<h3>Object 클래스</h3>
모든 클래스의 조상이다.
- 부모가 없는 클래스는 컴파일러에 의해 자동으로 Object클래스를 상속받게 된다.
- 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받게 된다.

<h2>오버라이딩</h2>
상속받은 조상의 메서드를 자신에게 맞게 변경하는 것
1. 선언부는 변경 불가능
2. 메서드 내부의 내용만 변경할 수 있다.
<h3>오버라이딩의 조건</h3>
1. 선언부가 조상 클래스의 메서드와 일치해야 한다.
2. 접근 제어자를 조상 클래스의 메서드 보다 좁은 범위로 변경할 수 없다.
3. 예외는 조상 클래스의 메서드 보다 많이 선언할 수 없다.
<h3>오버로딩과 오버라이딩 비교하기</h3>
오버로딩: 기존에 없는 새로운 메서드를 정의하는 것(생성자 모양의 다른 메서드)
오버라이딩: 상속받은 메서드의 내용을 변경하는 것

<h2>super와 super()</h2>
<h3>super</h3>
객체 자신을 가리키는 참조변수
인스턴스 메서드(생성자)내에서만 존재한다.
조상의 멤버를 자신의 멤버와 구별할 때 사용한다.
<h3>super()</h3>
조상의 생성자를 호출할 때 사용
조상의 멤버는 조상의 생성자를 호출해서 초기화한다.
생성자의 첫 줄에 반드시 생성자를 호출해야 한다.
- 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 자동으로 삽입한다.

<h2>package와 import</h2>
<h3>package</h3>
서로 관련된 클래스의 묶음이다.
패키지를 하나의 폴더라고 생각하면 된다.
클래스의 실제 이름은 패키지를 포함한다. (java.lang.String)
<h3>package 선언</h3>
패키지는 소스파일의 첫 번째 문장으로 단 한번만 선언한다.
같은 소스 파일의 클래스들은 모두 같은 패키지에 속한다.
패키지 선언이 없으면 default 패키지에 속하게 된다.
<h3>클래스 패스(classpath)</h3>
클래스 파일(.class)의 위ㅏ치를 알려주는 경로
classpath(환경변수)로 관리하며 경로간의 구분자는 ';'를 사용한다.
classpath에 패키지의 루트를 등록해줘야 한다.
<h3>import</h3>
클래스를 사용할 때 패키지 이름을 생략할 수 있게 해준다.
컴파일러에게 클래스가 속한 패키지를 알려준다.
java.lang 패키지는 중요한 클래스들이 모여있는 패키지이기 때문에 import를 생략할 수 이쎅 되어있다.(String,Object, System)
선언 방법: import 패키지명.클래스명;
import는 패키지와 클래스 선언 사이에 존재한다.
<h3>static import</h3>
static 멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.
- import static java.lang.System.out;
- 위처럼 선언 해주면 out.println("출력!"); 이렇게 사용할 수 있다.

<h2>접근제어자</h2>
<h3>제어자</h3>
클래스와 클래스의 멤버(변수, 메서드)에 부가적인 의미를 부여한다.
- 접근 제어자: public, protected, (default), private
- 그 외: static, final, abstract ...
하나의 대상에 여러 제어자를 같이 사용 가능하다.(접근 제어자는 하나만))
- 순서는 상관 없지만 주로 접근 제어자를 제일 왼쪽에 선언한다.
- public static void main(String[] args){}
<h3>static</h3>
멤버변수, 메서드, 초기화 블럭에 static이 사용될 수 있다.
<h3>final</h3>
클래스, 메서드, 멤버변수, 지역변수에 final이 사용될 수 있다.
대표적인 final 클래스로 String과 Math가 있다.
생성자를 이용하여 final 멤버변수를 초기화 할 수 있다.
- final이 붙은 변수는 상수이기 때문에 보통은 선언과 동시에 초기화를 진행해야 하지만 인스턴스 변수의 경수 생성자에 의해 초기화할 수 있다.
❗️final을 쓴 적이 많이 없어서 정확히는 모르겠다. 예시 확인하자!
<h3>abstract</h3>
클래스, 메서드에 abstract이 사용될 수 있다.
<h3>접근제어자</h3>
private: 같은 클래스 내에서만 접근이 가능하다.
default: 같은 패키지 내에서만 접근이 가능하다.(생략 가능)
protected: 같은 패키지 내에서, 그리도 다른 패키지의 자손 클래스에서 접근이 가능하다.
public: 접근 제한이 전혀 없다.

주의사항
1. 메서드에 static과 abstract를 함께 사용할 수 없다. (static은 몸통이 있는 메서드에만 사용할 수 있다.)
2. 클래스에 abstract와 final을 동시에 사용할 수 없다. (클래스에 사용되는 final은 클래스를 완성할 수 없다는 의미, abstract는 상속을 통해 완성되어야 한다는 의미이므로 서로 모순된다.)
3. abstract메서드의 접근 제어자가 private일 수 없다. (asbstact 메서드는 자손 클래스에 구현하기 위해 접근해야 하기 때문이다.)
4. 메서드에 private와 final을 같이 사용할 필요는 없다. (접근제어자가 private인 메서드는 오버라이딩 될 수 없기 때문이다. 둘 중하나만 사용해도 의미가 충분하다.)

<h2>캡슐화</h2>
<h3>접근 제어자를 사용하는 이유?</h3>
외부로부터 데이터를 보호하기 위해 사용한다.
내부적으로만 사용되는 것을 외부로 노출시키지 않고 감추기 위해서 사용된다.
이렇게 데이터를 보호하는 것을 캡슐화라고 부른다.

<h2>다형성</h2>
여러 가지 형태를 가질 수 있는 능력이다.
조상 타입의 참조변수로 자손 타입의 객체를 다루는 것이다.
- 조상 타입의 참조변수로 자손 타입의 객체를 다룰 수 있다.
- 하지만 조상 타입에는 없는, 자손 타입만 가지고 있는 기능 및 속성들을 사용할 수 없다.


<h2>참조변수의 형변환</h2>
- 사용할 수 있는 멤버의 개수를 조절하는 것
- 조상, 자손 관계의 참조변수는 서로 형변환이 가능
- 
<h2>매개변수 다형성</h2>
참조형 매개변수는 메서드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.
부모 클래스를 참조형 매개변수로 사용해서 자식클래스들을 하나의 메서드로 처리할 수 있다.

        public static void main(String[] args) {
        Animal[] animals = new Animal[3];

        animals[0] = new Animal();
        animals[1] = new Dog();
        animals[2] = new Bird();

        for (Animal animal : animals) {
            animal.move();
            animal.onomatopoeia();
            System.out.println();
        }
        // 이건 좀 익숙하지가 않네
        
        
        public static void main(String[] args) {
            Parent[] parents = new Parent[3];
            parents[0] = new Child1();
            parents[1] = new Child2();
            parents[2] = new Child3();

            for (Parent child : parents) {
                child.accost();
            }
        }
        🧐 for문에서 Parent 타입의 child는 parents를 참조하는 거겠지?
        
<h2>추상 클래스</h2>
<h3>추상 클래스의 형태</h3>
일반 클래스와 똑같은데 추상 메서드가 추가된 미완성된 클래스!

<h2>인터페이스</h2>
추상 메서드의 집합이다.
구현된 것이 전혀 없는 설계도이다.
모든 멤버가 public이다.
상수 이외의 인스턴스 변수, 클래스 변수는 가질 수 없다.
    interface 인터페이스이름{ 
    public static final 타입 상수이름 = 값; // 상수}
    public abstract 메서드 이름 (매개변수목록); //추상메서드
<h3>인터페이스의 상속</h3>
인터페이스의 조상은 인터페이스만 가능하다.
인터페이스는 클래스처럼 Oject가 최고 조상이 아니다.
추상 메서드는 어차피 상속 받으면서 구현부를 작성하기 때문에 충돌해도 상관 없다.
따라서 다중 상속이 가능하다
<h3>인터페이스의 구현</h3>
인터페이스에 정의된 추상 메서드를 완성하는 것이다.
class 클래스이름 implements 인터페이스 이름 { ... }
클래스에서 implements 라는 키워드를 사용하여 인터페이스를 구현한다.
클래스에선 implements 인터페이스끼리는 extends
<h2>인터페이스의 다형성</h2>
<h3>인터페이스 return 타입</h3>
인터페이스를 메서드의 반환타입으로 저장할 수 있다.
<h2>인터페이스의 장점</h2>
두 객체 간의 '연결, 대화, 소통'을 돕는 '중간 다리 역할'을 합니다.
선언(설계)과 구현을 분리시킬 수 있게 해준다.
