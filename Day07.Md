<h1>객체지향 Part.2</h1>
<h2>상속</h2>
기존의 클래스로 새로운 클래스를 작성하는 것. 두 클래스를 부모와 자식으로 맺어주는 것
extends 키워드를 사용하여 관계를 맺어준다.
<h3>상속의 조건</h3>
1. 자손은 조상의 모든 멤버를 상속 받는다.
- 생성자와 초기화 블럭은 제외된다.
2. 자손의 멤버 개수는 조상보다 적을 수 없다.
- 항상 같거나 많다.
3. 자손의 변경은 조상에게 영향을 미치지 않는다.

<h3>포함 관계</h3>
클래스의 멤버로 참조변수를 선언하는 것
작은 단위의 클래스를 만들고, 이들을 조합해서 클래스를 만든다.

<h3>관계 결정</h3>
상속관계: ~은 ~이다. (is-a)
포함관계: ~은 ~을 가지고 있다. (has-a)
<h3>단일 상속</h3>
Java는 단일 상속만을 허용한다.
비중이 높은 클래스 하나만 상속관계로 하고 나머지는 포함관계를 사용하는 방법으로 풀어낼 수 있다.
다중 상속을 허용할 경우 문제가 발생할 수 있다. (Diamond Problem)
<h3>Object 클래스</h3>
모든 클래스의 조상이다.
- 부모가 없는 클래스는 컴파일러에 의해 자동으로 Object클래스를 상속받게 된다.
- 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받게 된다.

<h2>오버라이딩</h2>
상속받은 조상의 메서드를 자신에게 맞게 변경하는 것
1. 선언부는 변경 불가능
2. 메서드 내부의 내용만 변경할 수 있다.
<h3>오버라이딩의 조건</h3>
1. 선언부가 조상 클래스의 메서드와 일치해야 한다.
2. 접근 제어자를 조상 클래스의 메서드 보다 좁은 범위로 변경할 수 없다.
3. 예외는 조상 클래스의 메서드 보다 많이 선언할 수 없다.
<h3>오버로딩과 오버라이딩 비교하기</h3>
오버로딩: 기존에 없는 새로운 메서드를 정의하는 것(생성자 모양의 다른 메서드)
오버라이딩: 상속받은 메서드의 내용을 변경하는 것

<h2>super와 super()</h2>
<h3>super</h3>
객체 자신을 가리키는 참조변수
인스턴스 메서드(생성자)내에서만 존재한다.
조상의 멤버를 자신의 멤버와 구별할 때 사용한다.
<h3>super()</h3>
조상의 생성자를 호출할 때 사용
조상의 멤버는 조상의 생성자를 호출해서 초기화한다.
생성자의 첫 줄에 반드시 생성자를 호출해야 한다.
- 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 자동으로 삽입한다.

<h2>package와 import</h2>
<h3>package</h3>
서로 관련된 클래스의 묶음이다.
패키지를 하나의 폴더라고 생각하면 된다.
클래스의 실제 이름은 패키지를 포함한다. (java.lang.String)
<h3>package 선언</h3>
패키지는 소스파일의 첫 번째 문장으로 단 한번만 선언한다.
같은 소스 파일의 클래스들은 모두 같은 패키지에 속한다.
패키지 선언이 없으면 default 패키지에 속하게 된다.
<h3>클래스 패스(classpath)</h3>
클래스 파일(.class)
<h2>클래스 패스(classpath)</h2>
<h3></h3>
<h3></h3>

<h2>캡슐화</h2>
<h3></h3>
<h3></h3>
<h2>다양성</h2>
<h3></h3>
<h3></h3>

<h2>참조변수의 형변환</h2>

<h3></h3>
<h3></h3>
<h2>매개변수 다형성</h2>
<h3></h3>
<h3></h3>
<h2>추상 클래스</h2>
<h3></h3>
<h3></h3>
<h2>인터페이스</h2>
<h3></h3>
<h3></h3>

<h2>인터페이스의 다형성</h2>
<h3></h3>
<h3></h3>
<h2>인터페이스의 장점</h2>
<h3></h3>
<h3></h3>
  
  
<h3></h3>
<h1><h1/>
<h1><h1/>
<h1><h1/>
<h1><h1/>
